test_error_1241_06162025
Correction 1: symbolic_decoder.js
Original code:
    validateAndCorrect(code) {
        // Remove any whitespace
        code = code.trim();
        
        // Check basic format
        if (!/^[A-Za-z0-9αβγδ]{16,33}$/.test(code)) {
            return { valid: false, error: 'Invalid character set' };
        }
        
        // Extract and verify checksum
        const checksum = code[code.length - 1];
        const payload = code.slice(0, -1);
        
        if (this.verifyChecksum(payload, checksum)) {
            return { valid: true, code: payload };
        }
        
        // Attempt error correction
        const corrected = this.attemptErrorCorrection(payload);
        if (corrected) {
            return { valid: true, code: corrected, corrected: true };
        }
        
        return { valid: false, error: 'Checksum validation failed' };
    }
Replaced with:
validateAndCorrect(code) {
    code = code.trim();
    
    // FIXED: Include all possible encoder symbols
    if (!/^[A-Za-z0-9!@#$%αβγδ]{16,33}$/.test(code)) {
        return { valid: false, error: 'Invalid character set' };
    }
    
    // Extract and verify checksum
    const checksum = code[code.length - 1];
    const payload = code.slice(0, -1);
    
    if (this.verifyChecksum(payload, checksum)) {
        return { valid: true, code: payload };
    }
    
    // Attempt error correction
    const corrected = this.attemptErrorCorrection(payload);
    if (corrected) {
        return { valid: true, code: corrected, corrected: true };
    }
    
    return { valid: false, error: 'Checksum validation failed' };
}
Correction 2: symbolic_encoder.js
Original code:
    summarizeShapeTypes(shapes) {
        const types = shapes.map(s => s.type);
        const unique = [...new Set(types)];
        
        if (unique.length === 1) return unique[0] + 's';
        if (unique.length === 2) return unique.join(' and ');
        return 'varied forms';
    }
Replaced with:
summarizeShapeTypes(shapes) {
    if (!shapes || shapes.length === 0) return 'empty space';
    
    const types = shapes
        .map(s => s.type)
        .filter(t => t && t !== 'undefined' && t !== 'unknown'); // Filter out undefined (Temporary)
    
    if (types.length === 0) return 'forms'; // Fallback when all undefined (Temporary)
    
    const unique = [...new Set(types)];
    
    if (unique.length === 1) return unique[0] + 's';
    if (unique.length === 2) return unique.join(' and ');
    return 'varied forms';
}
Correction 3: symbolic_encoder.js
Original code:
this.EDGE_THRESHOLD = this.mode === 'mobile' ? 100 : 64;
Replaced with:
    this.EDGE_THRESHOLD = options.edgeThreshold || this.mode === 'mobile' ? 100 : 64;
    this.MIN_SHAPE_AREA = options.minShapeArea || 50; // Increase from 20
    this.MAX_SHAPES = options.maxShapes || 50; // Limit shape count
Correction 4: symbolic_encoder
Added:
clusterShapes(shapes, maxCount = 50) {
    if (shapes.length <= maxCount) return shapes;
    
    // Sort by importance
    shapes.sort((a, b) => b.symbolWeight - a.symbolWeight);
    
    // Take top shapes
    const primaryShapes = shapes.slice(0, maxCount * 0.6);
    const remaining = shapes.slice(maxCount * 0.6);
    
    // Cluster nearby shapes
    const clusters = [];
    remaining.forEach(shape => {
        const nearestCluster = clusters.find(c => 
            Math.abs(c.centroid.x - shape.centroid.x) < 50 &&
            Math.abs(c.centroid.y - shape.centroid.y) < 50
        );
        
        if (nearestCluster) {
            nearestCluster.shapes.push(shape);
            // Update cluster centroid
            nearestCluster.centroid.x = 
                nearestCluster.shapes.reduce((sum, s) => sum + s.centroid.x, 0) / 
                nearestCluster.shapes.length;
            nearestCluster.centroid.y = 
                nearestCluster.shapes.reduce((sum, s) => sum + s.centroid.y, 0) / 
                nearestCluster.shapes.length;
        } else {
            clusters.push({
                centroid: { ...shape.centroid },
                shapes: [shape],
                type: shape.type,
                area: shape.area,
                symbolWeight: shape.symbolWeight
            });
        }
    });
    
    // Convert clusters back to shapes
    const clusteredShapes = clusters.map(c => ({
        type: c.type || 'cluster',
        centroid: c.centroid,
        area: c.shapes.reduce((sum, s) => sum + s.area, 0),
        symbolWeight: c.shapes.reduce((sum, s) => sum + s.symbolWeight, 0) / c.shapes.length,
        boundingBox: this.calculateClusterBounds(c.shapes)
    }));
    
    return [...primaryShapes, ...clusteredShapes].slice(0, maxCount);
}
Correction 5: symbolic_encoder.js
Original code:
    extractShapes(edges, width, height) {
        const shapes = [];
        const visited = new Uint8Array(width * height);
        
        for (let y = 0; y < height; y += this.SAMPLE_RATE * 2) {
            for (let x = 0; x < width; x += this.SAMPLE_RATE * 2) {
                const idx = y * width + x;
                
                if (edges.map[idx] > this.EDGE_THRESHOLD && !visited[idx]) {
                    const shape = this.marchingSquares(edges.map, visited, x, y, width, height);
                    
                    if (shape.area > 20) {
                        shape.type = this.classifyShape(shape);
                        shape.symbolWeight = this.calculateSymbolWeight(shape);
                        shapes.push(shape);
                    }
                }
            }
        }
        
        // Sort by perceptual importance
        shapes.sort((a, b) => b.symbolWeight - a.symbolWeight);
        
        return shapes;
    }
Replaced with:
extractShapes(edges, width, height) {
    const shapes = [];
    const visited = new Uint8Array(width * height);
    
    // Increase sampling rate for pixel art detection
    const adaptiveSampleRate = this.detectPixelArt(edges.map, width, height) ? 
        this.SAMPLE_RATE * 4 : this.SAMPLE_RATE * 2;
    
    for (let y = 0; y < height; y += adaptiveSampleRate) {
        for (let x = 0; x < width; x += adaptiveSampleRate) {
            const idx = y * width + x;
            
            if (edges.map[idx] > this.EDGE_THRESHOLD && !visited[idx]) {
                const shape = this.marchingSquares(edges.map, visited, x, y, width, height);
                
                // Increased minimum area for pixel art
                if (shape.area > this.MIN_SHAPE_AREA) {
                    shape.type = this.classifyShape(shape);
                    shape.symbolWeight = this.calculateSymbolWeight(shape);
                    shapes.push(shape);
                }
            }
        }
    }
    
    // Cluster if too many shapes
    const finalShapes = this.clusterShapes(shapes, this.MAX_SHAPES);
    
    // Sort by perceptual importance
    finalShapes.sort((a, b) => b.symbolWeight - a.symbolWeight);
    
    return finalShapes;
}
Correction 6: symbolic_encoder.js
Added:
detectPixelArt(edgeMap, width, height) {
    // Sample grid regularity
    let gridScore = 0;
    const sampleSize = Math.min(100, width * height / 100);
    
    for (let i = 0; i < sampleSize; i++) {
        const idx = Math.floor(Math.random() * edgeMap.length);
        const x = idx % width;
        const y = Math.floor(idx / width);
        
        // Check for regular grid patterns
        if (x % 8 === 0 || y % 8 === 0) {
            if (edgeMap[idx] > this.EDGE_THRESHOLD) gridScore++;
        }
    }
    
    return gridScore > sampleSize * 0.3;
}